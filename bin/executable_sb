#!/usr/bin/env python3
"""
ServiceBench CLI - Unified command-line interface for ServiceBench automation.

Designed to work via SSH from any machine:
    ssh auto-mac sb jobs SNWT123456
    ssh main-mac sb status
    sb claim SNWT123 --remote production

Subcommands:
    jobs      Submit unassigned jobs for processing
    claim     Submit close-and-claim jobs
    status    Check system status
    stop      Stop all workers
    logs      View job logs from database
    recent    Show recent jobs

Author: ServiceBench Bot Team
"""

import argparse
import json
import os
import socket
import sys
from pathlib import Path
from typing import Any

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------

SERVER_PORT = 1017

# Server configurations with Tailscale hostnames and IP fallbacks
SERVERS = {
    "local": {
        "url": f"http://localhost:{SERVER_PORT}",
        "name": "Local",
    },
    "production": {
        "url": f"http://automation-mac.warthog-tetra.ts.net:{SERVER_PORT}",
        "fallback": f"http://100.103.90.28:{SERVER_PORT}",
        "name": "Production (auto-mac)",
    },
    "staging": {
        "url": f"http://main-mac.warthog-tetra.ts.net:{SERVER_PORT}",
        "fallback": f"http://100.78.213.47:{SERVER_PORT}",
        "name": "Staging (main-mac)",
    },
    "away": {
        "url": f"http://away-mac.warthog-tetra.ts.net:{SERVER_PORT}",
        "fallback": f"http://100.67.122.109:{SERVER_PORT}",
        "name": "Away (away-mac)",
    },
}

# Hostname to server mapping for auto-detection
HOSTNAME_MAP = {
    "automation-mac": "local",  # On auto-mac, use local
    "auto-mac": "local",
    "main-mac": "local",  # On main-mac, use local
    "away-mac": "local",  # On away-mac, use local
}

# ---------------------------------------------------------------------------
# Utility Functions
# ---------------------------------------------------------------------------


def get_hostname() -> str:
    """Get short hostname."""
    return socket.gethostname().split(".")[0].lower()


def auto_detect_server() -> str:
    """Auto-detect which server to use based on hostname."""
    hostname = get_hostname()
    for pattern, server in HOSTNAME_MAP.items():
        if pattern in hostname:
            return server
    return "local"


def get_server_url(server_name: str) -> str:
    """Get server URL with fallback support."""
    config = SERVERS.get(server_name, SERVERS["local"])
    return config["url"]


def make_request(
    method: str,
    endpoint: str,
    server: str,
    data: dict | None = None,
    timeout: int = 30,
) -> tuple[bool, Any]:
    """Make HTTP request to server. Returns (success, response_data)."""
    try:
        import requests
    except ImportError:
        # Fallback to curl if requests not available
        return make_curl_request(method, endpoint, server, data, timeout)

    url = f"{get_server_url(server)}{endpoint}"
    try:
        if method.upper() == "GET":
            resp = requests.get(url, timeout=timeout)
        else:
            resp = requests.post(url, json=data, timeout=timeout)

        if resp.status_code == 200:
            return True, resp.json()
        else:
            return False, {"error": f"HTTP {resp.status_code}", "body": resp.text}
    except requests.exceptions.ConnectionError:
        # Try fallback URL
        config = SERVERS.get(server, {})
        if "fallback" in config:
            fallback_url = f"{config['fallback']}{endpoint}"
            try:
                if method.upper() == "GET":
                    resp = requests.get(fallback_url, timeout=timeout)
                else:
                    resp = requests.post(fallback_url, json=data, timeout=timeout)
                if resp.status_code == 200:
                    return True, resp.json()
            except Exception:
                pass
        return False, {"error": "Connection failed"}
    except Exception as e:
        return False, {"error": str(e)}


def make_curl_request(
    method: str,
    endpoint: str,
    server: str,
    data: dict | None = None,
    timeout: int = 30,
) -> tuple[bool, Any]:
    """Fallback to curl if requests module not available."""
    import subprocess

    url = f"{get_server_url(server)}{endpoint}"
    cmd = ["curl", "-s", "-m", str(timeout)]

    if method.upper() == "POST":
        cmd.extend(["-X", "POST", "-H", "Content-Type: application/json"])
        if data:
            cmd.extend(["-d", json.dumps(data)])

    cmd.append(url)

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout + 5)
        if result.returncode == 0:
            return True, json.loads(result.stdout)
        return False, {"error": f"curl failed: {result.stderr}"}
    except Exception as e:
        return False, {"error": str(e)}


def print_success(msg: str) -> None:
    print(f"\033[92mâœ“\033[0m {msg}")


def print_error(msg: str) -> None:
    print(f"\033[91mâœ—\033[0m {msg}", file=sys.stderr)


def print_info(msg: str) -> None:
    print(f"\033[94mâ„¹\033[0m {msg}")


def print_warning(msg: str) -> None:
    print(f"\033[93mâš \033[0m {msg}")


def validate_job_ids(job_ids: list[str]) -> list[str]:
    """Validate and normalize job IDs."""
    valid = []
    for jid in job_ids:
        jid = jid.strip().upper()
        if jid.startswith("SNW") or jid.startswith("CNW"):
            valid.append(jid)
        elif jid:
            print_warning(f"Invalid job ID format: {jid}")
    return valid


# ---------------------------------------------------------------------------
# Command Handlers
# ---------------------------------------------------------------------------


def cmd_jobs(args: argparse.Namespace) -> int:
    """Submit unassigned jobs for processing."""
    job_ids = validate_job_ids(args.job_ids)
    if not job_ids:
        print_error("No valid job IDs provided")
        return 1

    print_info(f"Submitting {len(job_ids)} job(s) to {args.server}...")

    data = {
        "job_ids": job_ids,
        "workers": args.workers,
        "headless": not args.visible,
        "start_processing": True,
    }

    success, resp = make_request("POST", "/unassigned_jobs", args.server, data)

    if success:
        print_success(f"Queued {resp.get('queued_count', len(job_ids))} jobs")
        if resp.get("already_processed"):
            print_info(f"Already processed: {resp['already_processed']}")
        if resp.get("queue_size"):
            print_info(f"Queue size: {resp['queue_size']}")
        return 0
    else:
        print_error(f"Failed: {resp.get('error', 'Unknown error')}")
        return 1


def cmd_claim(args: argparse.Namespace) -> int:
    """Submit close-and-claim jobs."""
    job_ids = validate_job_ids(args.job_ids)
    if not job_ids:
        print_error("No valid job IDs provided")
        return 1

    print_info(f"Submitting {len(job_ids)} close-and-claim job(s) to {args.server}...")

    data = {
        "job_ids": job_ids,
        "specialized": args.specialized,
        "headless": not args.visible,
        "force": args.force,
    }
    if args.workers:
        data["workers"] = args.workers

    success, resp = make_request("POST", "/close_and_claim", args.server, data)

    if success:
        print_success(f"Queued {resp.get('queued_count', len(job_ids))} jobs")
        return 0
    else:
        print_error(f"Failed: {resp.get('error', 'Unknown error')}")
        return 1


def cmd_status(args: argparse.Namespace) -> int:
    """Check system status."""
    print_info(f"Checking status of {args.server}...")

    success, resp = make_request("GET", "/system_status", args.server)

    if success:
        print_success(f"Server: {SERVERS.get(args.server, {}).get('name', args.server)}")
        print(f"  Status: {resp.get('status', 'unknown')}")

        # Job processing info
        job_info = resp.get("job_processing", {})
        if job_info:
            print(f"  Job Queue: {job_info.get('queue_size', 0)}")
            print(f"  Job Workers: {'active' if job_info.get('processing_active') else 'idle'}")

        # Claim processing info
        claim_info = resp.get("claim_processing", {})
        if claim_info:
            print(f"  Claim Queue: {claim_info.get('queue_size', 0)}")
            print(f"  Claim Workers: {'active' if claim_info.get('processing_active') else 'idle'}")

        if args.verbose:
            print("\nFull response:")
            print(json.dumps(resp, indent=2))
        return 0
    else:
        print_error(f"Failed to connect: {resp.get('error', 'Unknown error')}")
        return 1


def cmd_stop(args: argparse.Namespace) -> int:
    """Stop all workers."""
    print_info(f"Stopping all workers on {args.server}...")

    success, resp = make_request("POST", "/stop_all_workers", args.server)

    if success:
        print_success("Workers stopped")
        return 0
    else:
        print_error(f"Failed: {resp.get('error', 'Unknown error')}")
        return 1


def cmd_logs(args: argparse.Namespace) -> int:
    """View job logs from database.

    This command requires access to the servicebench-bot project for database access.
    """
    # Try to import from project (check multiple possible locations)
    project_paths = [
        Path.home() / "Projects/kahunacodes/active/servicebench-bot-worktrees/running",
        Path.home() / "Projects/kahunacodes/active/mileage-sync-worktrees/running",
        Path.home() / "Projects/kahunacodes/active/mileage-sync-worktrees/main",
        Path.home() / "servicebench-bot",  # Production on automation-mac
        Path.home() / "Projects/servicebench-bot",
        Path.home() / "Projects/mileage-sync",
        Path("/opt/servicebench-bot"),
    ]

    project_found = False
    project_path = None
    for path in project_paths:
        if path.exists() and (path / "cli" / "database_viewer.py").exists():
            project_found = True
            project_path = path
            break

    if not project_found:
        print_error("Database viewer requires servicebench-bot project")
        print_info("Use 'sb status' or 'sb recent' via API instead")
        return 1

    # Add project's venv site-packages FIRST (for dependencies)
    venv_site_packages = project_path / ".venv" / "lib"
    if venv_site_packages.exists():
        for py_dir in venv_site_packages.glob("python*/site-packages"):
            if str(py_dir) not in sys.path:
                sys.path.insert(0, str(py_dir))

    # Now add project path for imports
    sys.path.insert(0, str(project_path))

    try:
        from cli.database_viewer import print_job_info, print_daily_stats

        if args.job_id:
            print_job_info(args.job_id)
        else:
            print_daily_stats(args.date)
        return 0
    except Exception as e:
        print_error(f"Database error: {e}")
        return 1


def cmd_recent(args: argparse.Namespace) -> int:
    """Show recent jobs (requires project access)."""
    # Try to import from project (check multiple possible locations)
    project_paths = [
        Path.home() / "Projects/kahunacodes/active/servicebench-bot-worktrees/running",
        Path.home() / "Projects/kahunacodes/active/mileage-sync-worktrees/running",
        Path.home() / "Projects/kahunacodes/active/mileage-sync-worktrees/main",
        Path.home() / "servicebench-bot",  # Production on automation-mac
        Path.home() / "Projects/servicebench-bot",
        Path.home() / "Projects/mileage-sync",
        Path("/opt/servicebench-bot"),
    ]

    project_found = False
    project_path = None
    for path in project_paths:
        if path.exists() and (path / "cli" / "database_viewer.py").exists():
            project_found = True
            project_path = path
            break

    if not project_found:
        print_error("Recent jobs view requires servicebench-bot project")
        return 1

    # Add project's venv site-packages FIRST (for dependencies)
    venv_site_packages = project_path / ".venv" / "lib"
    if venv_site_packages.exists():
        for py_dir in venv_site_packages.glob("python*/site-packages"):
            if str(py_dir) not in sys.path:
                sys.path.insert(0, str(py_dir))

    # Now add project path for imports
    sys.path.insert(0, str(project_path))

    try:
        from cli.database_viewer import print_recent_jobs
        print_recent_jobs(args.limit)
        return 0
    except Exception as e:
        print_error(f"Database error: {e}")
        return 1


def cmd_context(args: argparse.Namespace) -> int:
    """Show full job context including parts, payments, claims, and comments.

    This command requires access to the servicebench-bot project for database access.
    """
    if not args.job_id:
        print_error("Job ID required")
        return 1

    # Try to import from project (check multiple possible locations)
    # Note: /Users/Apple/servicebench-bot is the production instance on automation-mac
    project_paths = [
        Path.home() / "Projects/kahunacodes/active/servicebench-bot-worktrees/running",
        Path.home() / "Projects/kahunacodes/active/mileage-sync-worktrees/running",
        Path.home() / "Projects/kahunacodes/active/mileage-sync-worktrees/main",
        Path.home() / "servicebench-bot",  # Production on automation-mac
        Path.home() / "Projects/servicebench-bot",
        Path.home() / "Projects/mileage-sync",
        Path("/opt/servicebench-bot"),
    ]

    project_found = False
    project_path = None
    for path in project_paths:
        if path.exists() and (path / "automation" / "job_database.py").exists():
            project_found = True
            project_path = path
            break

    if not project_found:
        print_error("Context viewer requires servicebench-bot project")
        return 1

    # Add project's venv site-packages FIRST (for dependencies like yaml)
    # This must happen before adding project path to avoid import errors
    venv_site_packages = project_path / ".venv" / "lib"
    if venv_site_packages.exists():
        for py_dir in venv_site_packages.glob("python*/site-packages"):
            if str(py_dir) not in sys.path:
                sys.path.insert(0, str(py_dir))

    # Now add project path for imports
    sys.path.insert(0, str(project_path))

    try:
        from automation.job_database import job_db

        job_id = args.job_id.strip().upper()
        context = job_db.get_job_summary(job_id)

        if not context:
            print_error(f"No data found for job {job_id}")
            return 1

        # Header
        print(f"\n{'='*60}")
        print(f"  JOB CONTEXT: {job_id}")
        print(f"{'='*60}\n")

        # Basic info
        print("ðŸ“‹ BASIC INFO")
        print(f"   Status:     {context.get('status', 'N/A')}")
        print(f"   Type:       {context.get('job_type', 'N/A')}")
        print(f"   Action:     {context.get('action', 'N/A')}")
        print(f"   Technician: {context.get('technician', 'N/A')}")
        print(f"   Location:   {context.get('location', 'N/A')}")
        print(f"   Scheduled:  {context.get('scheduled_date', 'N/A')}")
        if context.get('job_url'):
            print(f"   URL:        {context.get('job_url')}")
        print(f"   Created:    {context.get('created_at', 'N/A')}")
        print(f"   Updated:    {context.get('updated_at', 'N/A')}")
        if context.get('message'):
            print(f"   Message:    {context.get('message')}")

        # Parts
        parts = context.get('parts', [])
        if parts:
            print(f"\nðŸ”§ PARTS ({len(parts)})")
            for p in parts:
                status = p.get('part_status', 'Unknown')
                qty = p.get('part_quantity', 1)
                print(f"   â€¢ {p.get('part_name', 'Unknown')} [{status}] x{qty}")

        # Perils
        perils = context.get('perils', [])
        if perils:
            print(f"\nâš ï¸  PERILS ({len(perils)})")
            for p in perils:
                print(f"   â€¢ {p.get('peril_name', 'Unknown')} ({p.get('peril_type', 'N/A')})")

        # Payment
        payment = context.get('payment')
        if payment:
            print(f"\nðŸ’° PAYMENT")
            print(f"   Travel:      ${payment.get('travel_pay', 0):.2f}")
            print(f"   Labor:       ${payment.get('labor_pay', 0):.2f}")
            print(f"   Total:       ${payment.get('total_pay', 0):.2f}")
            if payment.get('is_multi_peril'):
                print(f"   Multi-peril: Yes")
            if payment.get('is_double_travel'):
                print(f"   Double travel: Yes")
            if payment.get('payment_notes'):
                print(f"   Notes:       {payment.get('payment_notes')}")

        # Claims
        claims = context.get('claims', [])
        if claims:
            print(f"\nðŸ“„ CLAIMS ({len(claims)})")
            for c in claims:
                print(f"   â€¢ {c.get('claim_id', 'Unknown')} - {c.get('status', 'N/A')}")
                if c.get('amount'):
                    print(f"     Amount: ${c.get('amount'):.2f}")

        # Comments
        comments = context.get('comments', [])
        if comments:
            print(f"\nðŸ’¬ COMMENTS ({len(comments)})")
            for c in comments[:5]:  # Limit to 5 most recent
                source = c.get('comment_source', 'unknown')
                text = c.get('comment_text', '')[:100]  # Truncate long comments
                if len(c.get('comment_text', '')) > 100:
                    text += "..."
                print(f"   [{source}] {text}")
            if len(comments) > 5:
                print(f"   ... and {len(comments) - 5} more comments")

        print(f"\n{'='*60}\n")

        # JSON output if verbose
        if args.verbose:
            print("ðŸ“Š RAW DATA (JSON)")
            print(json.dumps(context, indent=2, default=str))

        return 0

    except Exception as e:
        print_error(f"Context error: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


# ---------------------------------------------------------------------------
# Main Entry Point
# ---------------------------------------------------------------------------


def main() -> int:
    parser = argparse.ArgumentParser(
        prog="sb",
        description="ServiceBench CLI - SSH-friendly automation commands",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  sb jobs SNWT123456 SNWT789012    Submit unassigned jobs
  sb claim SNWT123456 --force      Submit close-and-claim job
  sb status                        Check system status
  sb status --remote production    Check remote server
  sb stop                          Stop all workers
  sb logs SNWT123456              View job logs
  sb context SNWT123456           Full job context (parts, payments, etc.)
  sb recent                        Show recent jobs

SSH Usage:
  ssh auto-mac sb jobs SNWT123456
  ssh auto-mac sb context SNWT123456
  ssh main-mac sb status
""",
    )

    # Global options
    parser.add_argument(
        "-r", "--remote",
        choices=list(SERVERS.keys()),
        default=None,
        help="Target server (default: auto-detect based on hostname)",
    )
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Verbose output",
    )

    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # --- jobs ---
    p_jobs = subparsers.add_parser("jobs", help="Submit unassigned jobs")
    p_jobs.add_argument("job_ids", nargs="+", help="Job IDs (SNWT...)")
    p_jobs.add_argument("-w", "--workers", type=int, default=2, help="Number of workers")
    p_jobs.add_argument("--visible", action="store_true", help="Show browser window")
    p_jobs.add_argument(
        "-r", "--remote",
        choices=list(SERVERS.keys()),
        dest="subcommand_remote",
        help="Target server",
    )
    p_jobs.set_defaults(func=cmd_jobs)

    # --- claim ---
    p_claim = subparsers.add_parser("claim", help="Submit close-and-claim jobs")
    p_claim.add_argument("job_ids", nargs="+", help="Job IDs (SNWT/CNWT...)")
    p_claim.add_argument("-w", "--workers", type=int, help="Number of workers")
    p_claim.add_argument("-s", "--specialized", action="store_true", help="Use specialized workers")
    p_claim.add_argument("-f", "--force", action="store_true", help="Force reprocessing")
    p_claim.add_argument("--visible", action="store_true", help="Show browser window")
    p_claim.add_argument(
        "-r", "--remote",
        choices=list(SERVERS.keys()),
        dest="subcommand_remote",
        help="Target server",
    )
    p_claim.set_defaults(func=cmd_claim)

    # --- status ---
    p_status = subparsers.add_parser("status", help="Check system status")
    p_status.add_argument(
        "-r", "--remote",
        choices=list(SERVERS.keys()),
        dest="subcommand_remote",
        help="Target server",
    )
    p_status.set_defaults(func=cmd_status)

    # --- stop ---
    p_stop = subparsers.add_parser("stop", help="Stop all workers")
    p_stop.add_argument(
        "-r", "--remote",
        choices=list(SERVERS.keys()),
        dest="subcommand_remote",
        help="Target server",
    )
    p_stop.set_defaults(func=cmd_stop)

    # --- logs ---
    p_logs = subparsers.add_parser("logs", help="View job logs")
    p_logs.add_argument("job_id", nargs="?", help="Job ID to look up")
    p_logs.add_argument("-d", "--date", help="Date for daily stats (YYYY-MM-DD)")
    p_logs.set_defaults(func=cmd_logs)

    # --- recent ---
    p_recent = subparsers.add_parser("recent", help="Show recent jobs")
    p_recent.add_argument("-n", "--limit", type=int, default=20, help="Number of jobs to show")
    p_recent.set_defaults(func=cmd_recent)

    # --- context ---
    p_context = subparsers.add_parser("context", help="Full job context (parts, payments, claims)")
    p_context.add_argument("job_id", help="Job ID to get context for")
    p_context.set_defaults(func=cmd_context)

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 1

    # Determine server (check both global and subcommand-level --remote)
    subcommand_remote = getattr(args, "subcommand_remote", None)
    if subcommand_remote:
        args.server = subcommand_remote
    elif args.remote:
        args.server = args.remote
    else:
        args.server = auto_detect_server()

    # Run command
    return args.func(args)


if __name__ == "__main__":
    sys.exit(main())
